import Demo01 from './demo01/preview'
import CodeTabs from 'components/codehike/code-tabs'

在现代 UI 框架的实现中，基本上都是基于数据驱动 UI 的思路来实现。因此当我们想要更新 UI 时，只需要在代码中更新对应的数据即可。

要实现**数据驱动 UI**，底层原理有两种主流的实现方案。

一种是**细粒度更新**。这种更新方式需要我们在更新之前，通过 Proxy 劫持数据，并将数据与对应的 UI 进行一一绑定。

当数据发生变化时，由于数据已经绑定了对应的 UI，那么，UI 的更新就会变得很容易，成本非常低。这也是这种更新方式的强大优势，许多框架例 `Solid.js、Svelte、angular` 现在都选择了这种更新方案，并在宣传中作为主要的优势与 React 进行对比。

不过，这种细粒度更新在将**数据与 UI 绑定起来的过程中，也会存在耗时**，在长列表更新的实现上由于方案的不同，也会存在不同程度的性能差异。在使用上，越复杂的数据结构，Proxy 劫持的过程就会越复杂，损耗的时间也越长，因此，在性能优化上，我们需要优先考虑简化数据结构。


另外一种是**全量更新**。这是 React 采用的思路。这种更新方式不需要绑定数据与 UI 的关系，而是通过**自顶向下**的方式，将整个页面的所有组件函数都执行一次。我们只需要在执行之前，把数据更新好即可，执行之后，就能得到更新之后的 UI。

很显然，如果不进行任何优化，这种更新方案的耗时肯定是比较长的。因此，React 在实现上，提出了一种 `diff` 算法来减少全量更新带来的耗时。核心的思路就是借鉴闭包思维，**尽可能的复用之前已经存在的运算结果**，从而减少重复的运算，最终**也能实现高效的细粒度更新**。

全量更新的优势主要体现在如下两个方面

+ 1、数据干净，不需要额外的处理，在复杂数据的处理场景下有明显的优势
+ 2、符合函数式的编程思想，在**代码的开发体验、执行的可预测性**上有明显的优势。因此，React 组件更容易被测试，在可维护性上有明显的优势

当然，最主要的缺点就是，想要通过 `diff` 算法来做到高效的细粒度更新，需要开发者在代码编写上做出配合才能实现，而开发者要做到这一点，对开发者的个人能力要求偏高。因此，React 推出了 React Compiler 来帮助初中级开发者实现这一点。

最理想的情况就是，我们可以通过深入掌握 diff 算法的精髓，能够主动调整代码的构建方式，从而完美的配合 React 实现高效的细粒度更新。

本章的目的从源码的角度带大家重新梳理一下 React 中 diff 算法的核心原理。实际上在前面的章节中我们已经零零碎碎的已经提到过了，因此这一章的内容更多的是在之前对源码理解的基础之上进行归纳。
