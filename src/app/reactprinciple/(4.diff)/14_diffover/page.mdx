### 假说论

我们在思考算法问题的时候，一定要谨记一个前提，那就是没有完美的算法可以解决所有问题。 因此，在设计一个算法时，我们需要充分考虑应用场景，然后提出一个假说，从而极大的减少问题的复杂性，让解决方案变得更加简单。

在 React 的 diff 算法中，当我们要对比前后两棵树的差异时，我们的目标是**尽可能少的创建节点**。但是由于 DOM 操作的可能性太复杂了，因此如果要全部对比出来，复杂度就非常高。达到了 O(n^ 3) 这个级别。之所以这么复杂，是因为节点不仅可以增加删除，还可以移动。

我们要分辨节点是否从子元素移动到了父元素，或者只是增加了一个父元素，判断过程非常复杂。因此，在设计 diff 算法时，React 放弃了这种情况的识别。他们根据实际情况提出的假说是：在实际情况中，整棵 DOM 树里，关于父子节点移动的情况是比较少的，因此，没有必要为了这种少部分情况加剧算法的压力。只要放弃识别这种情况，算法就能够得到极大的简化。


### 同层比较

因此，当我们放弃考虑移动的情况，那么 diff 算法就只需要做一个事情，那就是**同层比较**。

![](/images/reactprinciple/diff/override/1.png)

比较之后，只会有两种情况：

+ 1、比较结果相同，直接复用节点
+ 2、比较结果不同，则直接默认为从该节点开始，以下的全部节点都发生了变化，需要重新创建。

如下图所示，虽然节点只是发生了移动，但是在 diff 过程中，会被认为 A 节点已经被删除，然后重新创建它。

![](/images/reactprinciple/diff/override/2.png)


或者如下图所示，仅仅只是父节点发生了变化，那么父节点以下的所有子节点都会被重新创建。

![](/images/reactprinciple/diff/override/3.png)

因此，在同层比较的思路之下，我们只需要遍历一次 Fiber Tree，就可以完成整个 diff 过程。时间复杂度降低到了 O(n)。在这个基础之上，我们只需要进一步学习在 React 中，是如何比较节点是否可以被复用的就能够完全掌握 diff 算法了。

### 数组的比较

同层比较也存在两种情况。

+ 1、单节点比较
+ 2、多节点比较，即数组 -> 列表 的比较过程


这里我们需要特别注意的是，列表的比较过程，我们又必须**重新考虑节点移动**的情况。

这是因为在同一个层级中，判断出节点是否发生了移动，是相对而言成本很低的一种比较方式。而重新创建则有可能面临更高的执行成本。

例如，我们将长列表的最后一个元素移动到第一个位置，如果不考虑移动，那么整个列表都会被重建，显然是得不偿失的。因此，在后面的学习中，我们会详细介绍在同层级下，如何判断节点是否发生了移动。

![](/images/reactprinciple/diff/override/4.jpg)