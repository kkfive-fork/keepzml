import CodeTabs from 'components/codehike/code-tabs'

import Demo01 from './demo01'
import Demo02 from './demo02'
import Demo03 from './demo03'

函数调用栈对于代码的执行顺序有着非常重要的决定性影响。在完成一个应用程序的过程中，我们需要调用大量的函数来帮助我们完成各种功能，JavaScript 使用函数调用栈来管理所有函数的执行。

### *1*、函数体

当我们在代码中声明一个函数，如下

```ts
function foo() {}

var bar = () => {}
```

无论使用哪种方式，都能够创建一个函数体。函数体也是数据，每一个函数体都是一个对象，在代码解析阶段创建，被持久的存储于内存之中，也就是说，在程序的运行过程中，函数体始终存在。因此，我们可以在程序运行的任何时候调用该函数。

在其他语言，例如 Java，函数的声明会在代码打包的过程中就解析好，因此函数是静态的，在内存中会专门提供一个静态的方法区用于存放函数体。但是 JS 是在代码运行过程中对函数进行解析，因此在内存分配中，JS 并没有一个类似方法区的静态区域用于存储函数体，而是将函数体看待成为一个对象，存放于堆内存中。

### *2*、函数执行

函数调用栈是一种栈结构，因此遵循**先进后出，后进先出**的执行顺序。它用于管理函数的执行过程。

当函数在执行时，会被压入栈中，当函数执行完毕，会被弹出栈。

> 具体的细节是，参数、变量、声明等会进入到栈内存中记录执行过程，与此同时会创建对应的执行上下文在堆内存中进行管理。这里就不展开了，要详细了解更细节的内幕请阅读《JavaScript 核心进阶》学习


当我们调用一个新的函数时，一个新的执行上下文就会被创建。因此可以预见的是，每一个应用程序中，会有大量的执行上下文会被创建。JavaScript 引擎，使用栈的方式来管理与跟踪多个执行上下文的运行情况，我们称之为「函数调用栈」。在应用程序的运行过程中，栈顶是当前正在执行的上下文，并且正在执行的上下文始终都会在栈顶。也就意味着，无论任何时候，都只会有一个上下文正在执行。在执行过程中，如果遇到了新的函数，那么就会创建新的上下文，推入到栈顶，栈顶上下文执行完毕之后，就会出栈，并被垃圾回收器回收，新的栈顶上下文继续执行。

为了更加清晰的理解整个函数调用栈的执行过程，我们通过几个实例进行分析一下。

示例代码如下

```ts
var color = 'blue';

function changeColor() {
  var anotherColor = 'red';

  function swapColors() {
    var tempColor = anotherColor;
    anotherColor = color;
    color = tempColor;
  }

  swapColors();
}

changeColor();
```

首先，代码开始执行，全局上下文入栈。

<Demo01 />

首先，代码开始执行，直到遇到了 changeColor(); ，这一句代码表示调用函数 changeColor，因此它会创建自己的执行上下文，此时新创建的上下文入栈，并开始执行，此时全局上下文会处于挂起状态，暂停执行。changeColor 处于活跃状态

<Demo02 />

第三步：changeColor 的上下文入栈之后，开始执行其中的代码，执行过程中遇到了 swapColors(); ，激活了 swapColor 的执行上下文，于是新的上下文入栈，并开始执行。此时 changeColor 的上下文会调整为挂起状态，暂停执行。

<Demo03 />

第四步：在 swapColors 的执行过程中，并没有遇到新的函数调用，因此不会生成新的指向上下文，swapColors 函数顺利执行完毕。此时 swapColors 的上下文从栈中弹出，等待被回收。

swapColors 的执行上下文被弹出之后，changeColor 的执行上下文再次成为栈顶元素，代码从挂起状态激活，重新开始向下执行。

<Demo02 />

第五步：swapColors 继续执行的过程中，再没遇到新的函数被调用，因此顺利执行完毕，从函数调用栈中被弹出等待回收。此时，函数调用栈 ECStack 中，就只剩下全局上下文了。

<Demo01 />

注意：函数执行过程中，遇到 return，能直接终止可执行代码的执行，此时会直接将上下文弹出栈。


> 在浏览器环境下，代码包含在 script 标签中，浏览器会将 script 标签处理成为一个匿名函数参与到栈中。但它不是全局上下文。并且当我们在 chrome 中通过调试工具观察函数调用栈时，看不到全局上下文入栈。这也是默认全局上下文始终存在。但我们在学习时仍然会将全局上下文加入到理解中来，并且忽略 Script 标签生成的匿名函数。


### *3*、同步任务

函数调用栈是用来管理函数的执行。我们经常提到的**同步**执行，指的就是单线程中，代码按照函数调用栈的执行顺序，依次执行的过程。这一点大家要仔细体会。