事件循环是一个比较复杂的体系，解释起来非常的麻烦。

不过好在我们前面已经将步骤分别拆分进行了详细解读，做了大量的铺垫。因此，这篇文章我们只需要将前面的知识点进行一个汇总，就可以很容易的理解事件循环的原理了。

这里主要描述一下整个事件循环的流程。

首先，事件循环是有多个**宏任务(macro-tasks)**队列组成。这些队列通常由其他线程直接参与执行，例如

+ 由**定时器线程**参与的定时器任务队列
+ 由 **HTTP 线程**参与的请求回调任务队列
+ 由UI渲染线程参与的 `requestAnimationFrame/requestIdleCallback` 回调任务队列
+ 由主线程参与的 `script` 脚本任务队列
+ 由I/O事件线程参与的事件回调队列

**每一轮 Loop 的开始，都是由宏任务发起**。直到当前所有的宏任务执行队列中的任务全部执行完毕，才会进入下一轮的 Loop。

单个任务的执行，通过**函数调用栈**来完成。函数调用栈清空之后，然后开始执行 `Promise` 的执行队列。**Promise 的执行队列清空之后，表示当前单个宏任务执行完毕。** 因此，我们也称 Promise 的执行队列为内部维护的队列，或者称之为**微任务队列（micro-tasks）**

Promise 任务队列在执行过程中，任然会产生新的 Promise 任务，因此，Promise 任务队列会不断的执行，直到当前的 Promise 任务队列执行完毕。

宏任务队列，在执行过程中，也会产生新的宏任务。但是，这些新产生的任务，会放入到下一个宏任务队列或者临时队列中，不会对当前的宏任务队列产生影响。 


> 同一时间，不会存在有两个任务同时执行的情况。UI 渲染也是一个任务，也不会与其他任务同时执行，因此我们常常说，UI 渲染与 JS 代码是互斥的关系。

### 事件循环与刷新率

需要特别注意的是，事件循环的轮次并不与刷新率保持一致。在 60hz 的显示器上，刷新率会在 16.7ms 执行一次，但是在这个过程当中，事件循环可能会执行好几轮。事件循环并没有固定的执行频率，而是由浏览器的调度算法决定的。