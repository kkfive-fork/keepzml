import CodeTabs from 'components/codehike/code-tabs'
import Preview from 'components/preview'
import Demo01 from './demo01'

<Preview><Demo01 /></Preview>
<CodeTabs>
```tsx !!tabs index.tsx -c
!from ./Demo01/index.tsx
```

```tsx !!tabs list.tsx -c
!from ./Demo01/list.tsx
```

```tsx !!tabs controller.ts -c
!from ./Demo01/controller.ts
```

```tsx !!tabs service.ts -c
!from ./Demo01/service.ts
```

```tsx !!tabs api.ts -c
!from ./Demo01/api.ts
```
</CodeTabs>


### 一、前置场景

在前面一章，我们基于项目架构整体，为大家分享了 MVC 模式的学习。但是我们知道，在 MVC 模式中，由于 M 数据模型层常常会由于需求的复杂性高、后端的配合度低等实际情况而变得非常复杂。在数据层，我们要处理的数据包括但不限于

1、定义应用层需要使用的数据类型

2、向服务端请求数据结果

3、验证返回的数据类型是否符合要求，例如，我们通常会使用 zod 进行类型判断

4、对接口返回的数据进行二次处理，以达到应用层的使用需求。这种情况是造成数据模型层复杂度非常高的主要原因。例如，我们前端封装好的一个 UI 组件需要的数据格式是一个树形结构。但是后端返回的接口却是一个扁平化的数组结构。那么此时，我们就需要针对该数组结构做二次处理以达到 View 层的使用标准。

因此，单独的只考虑 MVC 架构，还无法非常完整的处理好我们的项目架构。在此基础之上，我们还需要 BFF 架构理念来帮助我们进一步解耦数据层的复杂情况。



### 二、BFF 架构

BFF 架构是 Backend For Frontend 的简称。通常情况下指的是在前端与后端之间设计一个**中间层**，用于处理前后端之间数据的差异。例如，对于一个前端页面而言，需要的数据分别来自两个接口，如果把这个逻辑交给前端来处理，前端的场景就变得复杂了，我们需要思考如何在初始化直接请求两个接口的情况。

> 由于缺乏架构思维的加持，许多自学成才的程序员就很难优雅的处理这种情况

那么此时，一个比较好的做法，就是在前端与后端之间，设计一个 node 服务，专门用于聚合处理后端多个接口的逻辑。然后对于前端来说，一个页面，或者一个组件单位，永远只有一个接口，这样处理起来就非常简单了。

这种解耦的做法，是把数据都处理从前端页面应用层剥离出去，后置于中间层。而这种加一个中间层的架构思维，就是 BFF 架构。

在一些比较大的团队中，经常会使用这种方案，在前端与后端之间还有一个中间层 node 端。在后端的项目全局架构思维中，BFF 架构思维多用于微服务架构。

但是这种做法，却并不是最完美的解决方案。主要的缺点表现如下

1、沟通成本高，团队沟通过程中方案的争议点比较多。通常情况下，中间层的逻辑职责划分并不明确，可以前端做，也可以后端做，也可以中间层做，因此，由于 node 中间层的存在，在项目管能力理薄弱的团队，往往会因此产生大量的争吵、甩锅、推诿等现象

2、维护成本更高。单独起一个 node 中间层服务，那么就需要专门针对 node 做更多的维护工作，包括日志、异常监控、稳定性维护、问题排查方案等等

3、进一步低智化、边缘化前端开发。在管理良好的 BFF 项目架构模式之下，前端开发所涉及的业务问题会更少，因此长期处于这种情况之下，普通前端开发会对项目整体架构的理解几乎一无所知，项目复杂度不够，从而缺乏核心能力的沉淀。

4、灵活性不足。如果中间层开发组与前端业务层开发组，不是同一波人，那么一些更具体的方案选择，灵活性会大打折扣。通常会遵循更为死板的架构标准，从而让简单的问题复杂化。例如：有的页面，如果本身只需要一个接口，但是由于 node 中间层的存在，及时本身就不需要进行额外的处理，但是也依然需要按照架构规范从 node 服务走一边。



### 二、BFF 在前端项目中的运用

我们可以脱离服务端，仅在单独的 react 前端项目中运用 `BFF + MVC` 架构来解决数据层比较复杂的问题。

理念依旧是一样的，只是换了一个场景。我们只需要把 `MVC` 模式中的 M 作为中间层来理解即可。核心的代码请看右侧案例演示

我们预设一个场景，前端页面要展示一个列表中的数据，由于后端技术方案的问题，导致了该列表是由两个接口返回两个数组拼接而成。此时，我们要如何做呢？

在非 TS 的项目中，第一步，我们需要有一个 `api.js` 的文件，该文件主要用于编写两个请求函数，该请求需要与接口文档保持完全一致，在前端项目中，接口的形式需要返回 Promise。

```ts api.ts -c
!from ./demo01/api.ts
```

> 在 MVC 模式下，UI 层被成为 View 层，在 BFF 模式下，UI 层被称为应用层，由于前端的项目通常是 MVC 与 BFF 混合使用，因此后续的文章可能会随机用到某一个表述，我们明白表达的是什么就行了

正常情况下，如果应用层只需要一个接口，并且接口的返回类型与 View 层需要的数据类型完全一致，那么我们就可以在 View 层中使用

```js
// index.tsx
import {getUsersInfo} from './api'
```

但是此时，API 只是为了与后端接口保持一致，方便可读性，我们能够从代码结构中清晰快速的明确当前接口是怎么回事。情况的混乱导致我们并不能在应用层直接使用 `api`。此时应用层需要的是两个接口返回的数组合并成为一个数组，因此，这个时候，我们需要抽象出来一个 `service` 层，用于处理数据的请求

在当前文件夹下，定义一个 `service.ts`，编写代码如下

```ts service.ts -c
!from ./demo01/service.ts
```

如果数组的合并前后顺序无所谓，我们可以使用 `Promise.all`，如果有先后关系要求，则可以使用 `await`。极少数的情况下可能会存在竞争关系，则使用 `Promise.race`

`service` 层通常用来处理一个组件需要多个接口才能完成初始化的情况，并最终向应用层或者 `controller` 层**提供一个唯一数据源**。如果该页面的接口本身就只有一个，那么则可以不需要它。或者不需要 `api` 层，此时可以由你自己根据偏好来决定。

此时，我们发现，接口返回的数据格式中，缺乏一个描述字段，`.desc`，当前完整的格式如下

```js
{
  gender: 'female',
  email: 'clementine.lambert@example.com',
  name: {
    title: 'Miss',
    first: 'Clémentine',
    last: 'Lambert'
  },
  nat: 'FR',
  picture: {
    large: 'https://randomuser.me/api/portraits/women/15.jpg',
    medium: 'https://randomuser.me/api/portraits/med/women/15.jpg',
    thumbnail: 'https://randomuser.me/api/portraits/thumb/women/15.jpg'
  }
}
```

针对这个数据格式，我们前端有额外的几个需求要调整，以简化应用层的使用

1、需要补充一个字段 `.desc`

2、name 我希望是完整的名称，JSX 中使用 `.name` 即可渲染

3、我已经明确知道此时我仅需要缩略图，不需要大图和中图，因此数据格式调整为 `.thumbnail`

此时我们发现，虽然通过 `service` 的组合，我们得到了一个完整的数组结构，但是由于字段不满足需求，因此我们需要额外对该数组进行二次处理，此时，我们需要抽象出来一个 `controller` 层，用于处理这些数据。

`controller` 层通常用于处理以下逻辑

+ 1、验证数据字段内容与类型是否符合预期
+ 2、验证安全性等其他额外逻辑
+ 3、二次处理，整理成为应用层需要的结构

`controller` 在不同的场景中，通常用于直接与 `应用层/View层` 对接。例如，在 `nest.js` 中，`controller` 负责处理来自前端的请求，然后将结果返回给前端。

在我们这个场景，可以直接定义一个 `controller.ts` 文件，然后编写如下代码完成逻辑

```ts controller.ts -c
!from ./demo01/controller.ts
```

那么在应用层中，则直接使用 `controller` 返回的 Promise 来获取数据

```ts
// index.tsx
import { getOverUsersInfo } from './controller'
```

此时的组件文件结构为

```javascript
+ home // 表示页面
  - index.tsx
  - controller.tsx
  - service.tsx
  - api.tsx
  + components  // 表示子组件文件夹，如果子组件简单也可以展开组织
```

通常情况下，`controller` 层是必须要存在的，因为一个成熟的架构需要对后端返回的数据结果做类型验证、安全性验证等工作，这是每个接口都必须要做的事情。当我们确保返回给应用层的数据是安全可用的之后，那么在应用层中，则可以简单很多，在 `use + Suspense` 的场景下，我们可以不用在 JSX 中做数据安全性验证，我们的代码可以直接这样写.

注意看我在 map 中对 `item` 的运用方式。 直接使用 `item.desc`，而不是 `item.desc || ''`

```tsx list.tsx -c
!from ./demo01/list.tsx
```

> 数据校验的方式不是本小册要分享的内容。但是我们可以自己封装，也可以使用 [zod](https://zod.dev/README_ZH) 这个工具。数据校验通常包括的逻辑有类型校验、缺省值补充、其他额外需求校验、小团队的项目可以简化这一过程，大型团队一般都比较重视。

完整代码在页面顶部展示，大家可以详细看一下


### 四、总结

在 `MVC` + `BFF` 混合的架构模式中，我们一定要做到的是，确保 `View` 的简洁性，无论情况如何复杂，我们都要做到**数据是唯一来源的、数据是拿来即用的**。而不要把数据的额外处理放到应用层中来处理。导致代码逻辑混乱，维护困难。

在前端开发中，由于直接以文件作为模块，并不需要像 `nest.js` 那种需要额外单独构建一套模块系统，因此，BFF 在前端项目中的运用非常灵活。我们可以非常自由的在每个组件中，根据具体场景决定自己是否需要使用 `service、api、controller`，或者仅使用他们中的一个。因此，这样的灵活性就确保了我们即可以以最简单的模块结构应对简单的后端接口，也可以以标准的文件结构应对不规范的后端接口。这样的灵活性是 node 中间层服务所不具备的。因此，直接在前端项目中使用 BFF 是一种开发成本与维护成本更低的方式

> 根据我的实践经验，大多数接口都可以通过沟通的方式简化大部分 service 与 controller 的逻辑。如果沟通失败，我们也有巧妙的方式来应对，从而在工作谈判中为自己争取更多有利的团队贡献素材。

由于本项目并没有采用 `TS`，因此类型相关的逻辑没有额外描述。如果你有相关的疑问，可以在尊享群或者直播里跟我探讨。
