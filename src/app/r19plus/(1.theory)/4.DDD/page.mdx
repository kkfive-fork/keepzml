import CodeTabs from 'components/codehike/code-tabs'
import Preview from 'components/preview'

DDD (domain-driven design)，领域驱动设计。是一种后端架构师讨论得比较多的架构设计思想。这里针对该思想做一个补充的原因是因为有许多朋友也在付费群里探讨它。想要搞清楚它到底是在说什么。

网上的介绍 DDD 的文章特别多，但是能讲一讲，就能够理解的文章，我看了几十篇，直接没有，都搞得云里雾里的。所以索性就在这里补充一篇，给大家扩充一下关于领域驱动设计的思维模式。

### *1*、传统 MVC 分层模型

首先我们要明确一个基础前提：领域驱动设计，是在传统 MVC 分层模型的基础之上，**随着项目业务的扩展**而衍生出来的一种设计思维。因此，在理解 DDD 之前，我们需要对 MVC 有一个比较深刻的认识。当然，MVC 前面我们也有提到，相信对它的理解大家都不会有什么困扰。

但是，这里有一个很重要定性我们需要强调一下，**MVC 分层思维，并不是根据业务特性进行分层，而是根据代码的功能特性进行划分**，例如

在后端项目中的 `controller` 层，负责接收用户的输入(接口请求)，然后调用模型中的逻辑完成逻辑处理并返回对应的数据。

因此，传统的分层架构，在项目变得越来越复杂的时候，就会出现另外一个比较严重的问题，那就是分层之后，某一层的文件太多了。例如，controller 层里面有 5000 个文件，这对项目的维护就是一个比较困难的事情。

```bash
+ controller
  - xxx1.ts
  - xxx2.ts
  - xxx3.ts
  - xxx4.ts
  - xxx5.ts
  - ...
  - xxx5000.ts
```

OK，这个时候，我们就很自然的想到，需要对数量庞大的 `controller` 层进行再次分类。


### *2*、业务内聚

但是怎么分类呢？就需要研究和探讨。一个比较常规的分类方式就是按照业务功能块直接在 controller 文件夹中创建更多的子文件夹。然后整个后端项目大概会长成这个样子。

```bash
+ controller
  + users
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ...
  + sale 
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ... 
  + orders 
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ... 

+ service
  + users
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ...
  + sale 
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ... 
  + orders 
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ... 
```

这也是被初中级开发者采用得比较多的做法。

但是这样做的一个问题就是，项目的业务模块之间耦合比较严重，不利于项目拆分，项目的可维护性也没有得到特别明显的提升，之前的问题只是被小幅度弱化并没有被解决。

另外，为什么我们要思考项目拆分呢？原因是因为当项目随着业务的发展规模变得庞大，那么将项目进行拆分是一个必然的趋势。因此，我们更好的选择，就是基于**业务内聚**的方式来进行重新分类。

在上面的分类中，我们已经基于业务，把项目模块分为了用户系统 **users**，销售系统**sale**，订单系统**orders**

那么，我们的代码结构应该调整如下

```ts
+ users // 用户系统
  + controller
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ...
  + service 
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ... 

+ sale // 销售系统
  + controller
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ...
  + service 
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ... 

+ orders // 订单系统
  + controller
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ...
  + service 
    - xxx1.ts
    - xxx2.ts
    - xxx3.ts
    - ... 
```

这就是业务内聚，这样做的好处就是，每一个业务系统都是非常独立的，与其他系统之间的耦合非常低。我们可以很方便的将其中某一个系统单独剥离出去形成一个完整的新的应用。

不仅在代码结构上要关注业务内聚，在数据库的设计上，我们也应该遵循业务内聚的原则进行设计。例如同样是地址管理，商家地址管理与用户地址管理，应该设计成两张表，分别归属于用户系统与商家系统中去。如果仅按照功能划分，可能就是设计到一张表里去了。

以业务为核心进行拆分，最终落点落在数据库的表现上，在服务端被称为一个领域 domain，因此业务内聚的架构思想，就是**领域驱动设计**。

domain 也是表达的一种范围，不过和作用域 scope 不同的是，domain 强调的是数据范围。


### 3、DDD 与组件化内聚

如果你看过我之前在 React 哲学 一文中，介绍的组件化内聚思想，你就会发现，DDD 的设计思维，与我之前提到的组件化内聚是**一模一样的底层思维**。只不过分别被运用到了不同的场景中。所以我在 React 哲学中提到的组件化内聚其实非常超前，有一些朋友仅利用该思维就可以在大厂里成功晋升，威力强大。

优秀的架构设计都殊途同归，不分前端后端，因此这也是我这里补充 DDD 架构思维的核心原因之一。


### 4、DDD 与微服务

DDD 是一种构架思维，微服务是一种具体的架构落地实践。正确的做法是我们应该使用 DDD 的设计思维去指导微服务的落地。否则，我们可以感受到许多后端架构师的微服务实践并不理想，服务与服务之间耦合严重，开发效率低，数据一致性处理困难，bug 多，因为他自己本身并没有领悟到业务内聚的精髓。

这也要求架构师必须对业务非常精通。能够合理的解耦表面上耦合的业务细节。


### 5、其他设计原则

其他设计原则我们就需要考虑的就是在分层模型中的细节。例如，基础能力我们会单独封装出来，成为基础设施层。在基础层上面去思考领域层，在领域层上面去思考用户交互层，或者与前端对接的中间层。

这里有一个很重要的一个设计原则就是**上层依赖下层，但是下层不能依赖上层**。

ok，就这样简单提一下，只要把控住了这几个大一点的思维模式，我们不需要画一个非常庞杂的业务图去理解 DDD，因为在不同的团队中，可能会在分层上有不同的理解。因此有的团队也许会多设计个一层或者两层，需求到位了你自然就知道应该加一层。因此这些东西不应该成为我们学习的负担，不需要去额外理解他们。

### 6、总结

优秀的架构师一定要有全局视野，不仅要对前端架构有深入的理解，对后端架构也要有差不多的认知，能够把前端、后端、业务结合起来思考的架构师，才是优秀的架构师。