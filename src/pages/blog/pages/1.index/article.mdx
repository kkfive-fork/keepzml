import Cardruntime from 'components/Cardruntime'
import MainCase from './case'

import AppText from './case/index.jsx?raw'
import apiText from './case/api.js?raw'
import ListText from './case/List.jsx?raw'

import Codepack from 'components/Codepack'



主观主义
教条主义
经验主义
机会主义
冒险主义
投降主义

```javascript
               结合实践
                  ^
                  |
              2   |   1
忽视理论 ---------------------> 重视理论
              4   |   3
                  |
               脱离实践
```

3、教条主义：纸上谈兵，脱离实践，无法落地，例如大厂程序员很难适应小厂的开发氛围和管理氛围，执行方案和落地容易不切实际，常见的学院派、大厂、优秀科班生、

2、经验主义：重视个人经验，忽视理论和逻辑。路径依赖：在过去某个时间，某个节点因为一些行动取得一些成功，然后就觉得这些办法在所有时间所有场景都能够取得成功，例如，炒房赚钱 + 多买房、套牢 --> 经验失效，把一时的现象，当成普遍的真理，时机与情况发生变化，经验就失效了。

4、机会主义：没有什么原则，全凭幻想和感觉，我觉得这样做更好，就这样做，这一点实际上在工作上的反面案例非常多。但是体现在学习上，就是学习没有方法和规划，全凭本能和感觉学习，因此常常学到的东西不成体系，无法形成有效的输出。觉得这样做可能会更好，就这样做。左倾和右倾、右倾：保守、该做的时候不做，又叫做机会主义与投降主义。向自己的惰性妥协。左倾就是激进的：体现在学习上就是，



教条主义：主观幻想理论都是对的

经验主义：主观幻想经验都是对的

机会主义：主观幻想幻想都是对的


最终导致的结果就是：无法输出、无法表达、容易忘记、觉得自己的知识不成体系，觉得自己基础薄弱，表达的东西经不起推敲，无法形成完整的逻辑闭环


1、实事求是：没有理论，就不能解决普遍的问题，你的学习效果不具备举一反三的能力。没有实践，就不能解决具体的问题，很容易在某一些特定的场景中不知所措。




接下来，我们要继续分享 React 19 的进阶内容。

基本思路会以架构思维出发，然后基于这个架构思维，用大量实践按钮覆盖更多的业务场景。本文先讲理论，后续的文章以实践为主实践。

---
### 一、项目结构设计

语义结构

```javascript
+ src
  - main.tsx // 表示项目入口文件
  + pages  // 表示页面
  + components // 表示共用基础组件，可复用
  + utils  // 表示共用工具方法
  + hooks  // 表示公用 hook 方法，与 utils 类似
  + other // 根据项目需求自行添加
```

**组件化内聚**

例如一个页面组件，对外是一个完整的 Home 组件，与 Home 组件相关的内容都尽量放置在 home 文件之内，对内再进行职能和角色的拆分。这是一种**高内聚的组件化思维**

```javascript
+ pages
  + home
    - index.tsx
    - index.d.ts
    - index.css
    - api.ts
    - model.ts   // Modal 数据层
    + components // 可能存在的子组件
```

### 二、组件内的 MVC 模式

在**对内**进行职能和角色的拆分时，我们要追求的目标就是**低耦合**

因此，我们可以遵循传统的 MVC 设计模式进行拆分。

MVC 大家都不陌生，但这里对于前端开发来说，比较困难的是如何对号入座。要做到融会贯通是一件比较困难的事情。

**`M，Model`**，数据模型，表示一个处理数据的对象或者模块，是一个数据模型。

> 在 React 中的架构模型中，数据模型是最难理解的一个部分。也是我们需要特别学习和关注的一个模块

**`V, View`**，视图，在前端通俗称之为 UI 层，在 React 组件内部，我们可以将 JSX 部分看成是 View 层。

**`C，Controller`**，控制器，数据变化时控制 UI 变化，在 React 中，定义在 useState 中的数据，自带控制器能力。当 state 中的数据发生了变化，UI 会自动变化，因此我们不会特别强调它，但是在 React 19 中，控制器会稍微有一些不同。我们要分享的架构模式，将数据存储在 promise 中，然后将 promise 存储在 state 中，因此，此时控制器将由 promise 的变化来承担。

而是直接说：数据驱动 UI

> 我们也可以把 setState 理解为控制器，它直接控制数据的变化，间接控制 UI 的变化


例如本文顶部的那个案例，我们用代码实现大概如下。其中

`index.jsx` 表示 View 层

`api.js` 表示 Model 层

`update` 表示控制器。


<Codepack files={{'index.jsx': AppText, 'api.js': apiText, 'List': ListText}} />


案例比较简单，所以大家理解起来应该不难。但普通的开发在复杂场景中，没有足够的能力支撑他严格践行 MVC 模式，经常会把数据与 UI 耦合在一起编写。从而导致了代码的可维护性变得非常低。

因此，在后续的实践案例中，我们需要进一步学习如何在各类复杂场景中践行 MVC 的设计模式。

### 三、在 promise 中存储数据

在学习时，我们需要花更多的精力放在 Model 层的思考上。在 React 19 中，由于提供了 `use + Suspense` 的语法方式，我们可以将数据存放在 promise 中，从而弱化副作用的语法表现，也因此，**我们可以不用在代码中依赖 `useEffect` 来实现异步逻辑**

因此，本小册在 Model 层的思考，都会依赖于 `use + Suspense` 的思路来实现，我们会优先将数据存储在 promise 中，然后通过 use 来获取数据。

基于以上架构思维原则，在同一个组件中，我们需要明确的是

+ 1、View 层只应该有一个入口获取数据，而不是多个
+ 2、如果你确实觉得需要多个入口，需要优先考虑拆分组件，然后满足第一条
+ 3、View 层不处理数据相关的任何逻辑，例如过滤数据，修改数据结构等，都应该在数据层处理好，View 层的数据应该是**拿来即用**的
